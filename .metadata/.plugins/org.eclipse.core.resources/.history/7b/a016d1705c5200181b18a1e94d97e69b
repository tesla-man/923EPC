/*
 * uart.c
 *
 *  Created on: May 7, 2018
 *      Author: Contovasilis
 */
#include "uart.h"
#include "gpio.h"
#include "interrupt.h"

volatile uint16_t result = 0;
volatile uint8_t flag = 0;

void initUART(){
    gpioStruct gpio;        //Configure UART pins
    gpio.port = PORT1;
    gpio.pins = PIN2 | PIN3;
    gpio.type = OUTPUT;
    gpio.af = AF1;
    gpio_init(&gpio);

    // Configure UART
    EUSCI_A0->CTLW0 |= EUSCI_A_CTLW0_SWRST; // Put eUSCI in reset
    EUSCI_A0->CTLW0 = EUSCI_A_CTLW0_SWRST | // Remain eUSCI in reset
            EUSCI_B_CTLW0_SSEL__SMCLK;      // Configure eUSCI clock source for SMCLK

    EUSCI_A0->BRW = 26;                     // 48000000/16/115200
    EUSCI_A0->MCTLW = EUSCI_A_MCTLW_OS16;

    EUSCI_A0->CTLW0 &= ~EUSCI_A_CTLW0_SWRST; // Initialize eUSCI
    EUSCI_A0->IFG &= ~EUSCI_A_IFG_RXIFG;    // Clear eUSCI RX interrupt flag
    EUSCI_A0->IE |= EUSCI_A_IE_RXIE;        // Enable USCI_A0 RX interrupt

    // Enable eUSCIA0 interrupt in NVIC module
    initNVIC(EUSCIA0_IRQn);
}

void uartWrite(uint8_t data){
    while(!(EUSCI_A0->IFG & EUSCI_A_IFG_TXIFG));
    EUSCI_A0->TXBUF = data;
}

uint8_t uartRead(){
    return EUSCI_A0->RXBUF;
}

uint16_t checkCR(){
    return flag
}
void EUSCIA0_IRQHandler(void)
{
    uint8_t data = 0;
    if (EUSCI_A0->IFG & EUSCI_A_IFG_RXIFG)
    {
        if((EUSCI_A0->RXBUF) != 0x0D){
            data = (EUSCI_A0->RXBUF) & 0x0F;
            result = result*10 + data;
        }
        else{
            flag = 1;
            while(!(EUSCI_A0->IFG & EUSCI_A_IFG_TXIFG));
            EUSCI_A0->TXBUF = 0x0A;
        }

        while(!(EUSCI_A0->IFG & EUSCI_A_IFG_TXIFG));
        EUSCI_A0->TXBUF = EUSCI_A0->RXBUF;
    }
}
