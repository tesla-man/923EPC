#include "msp.h"
#include "uart.h"
#include "delay.h"
#include "interrupt.h"
#include "term.h"
#include "math.h"

/**
 * main.c
 */
volatile uint8_t strig=0;
volatile  int voltage;
volatile float capture = 0;

int main(void) {
    volatile unsigned int i;
    float freq;

    initClock();

    P1->DIR |=BIT0;
    P1->OUT &=~BIT0;

    P2->REN |= BIT4;
    P2->SEL1 &= ~BIT4;
    P2->SEL0 |= BIT4;

    P5->SEL1 |= BIT4 | BIT5;                       // Configure P5.4 for ADC
    P5->SEL0 |= BIT4 | BIT5;


    uartInit();

    TIMER_A0->CCTL[1] = TIMER_A_CCTLN_CM_1 | // Capture rising edge,
            TIMER_A_CCTLN_CCIS_0 |          // Use CCI2A=ACLK,
            TIMER_A_CCTLN_CCIE |            // Enable capture interrupt
            TIMER_A_CCTLN_CAP |             // Enable capture mode,
            TIMER_A_CCTLN_SCS;              // Synchronous capture

    TIMER_A0->CTL |= TIMER_A_CTL_TASSEL_2 | // Use SMCLK as clock source,
            TIMER_A_CTL_MC_2 |              // Start timer in continuous mode
            //TIMER_A_CTL_ID__8 |
            TIMER_A_CTL_IE  |
            TIMER_A_CTL_CLR;                // clear TA0R


    // Enable global interrupt
    __enable_irq();

    // Enable ADC interrupt in NVIC module
    initNVIC(ADC14_IRQn);
    initNVIC(TA0_N_IRQn);

    // Sampling time, S&H=16, ADC14 on
    ADC14->CTL0 = ADC14_CTL0_SHT0_2      |
                  ADC14_CTL0_SHP         |
                  ADC14_CTL0_ON          |
                  ADC14_CTL0_SSEL__SMCLK |
                  ADC14_CTL0_DIV_7       |
                  ADC14_CTL0_MSC         |
                  ADC14_CTL0_CONSEQ_2;

    ADC14->CTL1 = ADC14_CTL1_RES_3;         // Use sampling timer, 14-bit conversion results


    ADC14->MCTL[0] |= ADC14_MCTLN_INCH_1 | ADC14_MCTLN_DIF | ADC14_MCTLN_VRSEL_14;   // A1 ADC input select; Vref=AVCC
    ADC14->IER0 |= ADC14_IER0_IE0;          // Enable ADC conv complete interrupt
    ADC14->CTL0 |= ADC14_CTL0_ENC | ADC14_CTL0_SC;

    while (1)
    {
       freq = 48000000/capture;
       //printf("%.5f         %.2f\n\r", freq, rmsresult);
       delay_ms(200);
    }
}

// ADC14 interrupt service routine

void ADC14_IRQHandler(void) {
    static uint16_t conv;
    static uint32_t rms = 8192;
    static uint64_t sum_square = 1UL * 512 * 8192 * 8192;

    conv = ADC14->MEM[0];


    sum_square -= sum_square / 512;
    sum_square += (uint64_t) conv * conv;
    if(rms==0) rms=1;
    rms = (rms+sum_square / 512 / rms)/2;

    //voltage = (6596*(rms-8191))/8191);
    voltage = rms/4096;
    printf("%d\r\n", rms);

}


void TA0_N_IRQHandler(void) {
    static uint16_t ovf = 0;

    if((TIMER_A0->CTL) & TIMER_A_CTL_IFG){
        if(ovf<756){
            ovf++;
        }
        TIMER_A0->CTL &= ~TIMER_A_CTL_IFG;
    }

    if(TIMER_A0->CCTL[1] & TIMER_A_CCTLN_CCIFG){
        capture = TIMER_A0->CCR[1] + ovf*65535 + 147;
        strig ^= 1;
        ovf = 0;
    }

    TIMER_A0->CTL |= TIMER_A_CTL_CLR;
    TIMER_A0->CCTL[1] &= ~TIMER_A_CCTLN_CCIFG;
}
